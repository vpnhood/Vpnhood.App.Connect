name: Publish AAB to Google Play & Replace Release Asset with Play-Signed APK

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write   # needed for gh release upload/delete-asset

    env:
      # Which release to use as source for the AAB
      TAG: latest
      # Pattern of the AAB asset name in that release:
      AAB_PATTERN: "*.aab"

      # Where to read version info (plain text files in repo)
      VERSION_NAME_FILE: ".release/version_name"
      VERSION_CODE_FILE: ".release/version_code"

      # Track / Rollout (change if needed)
      TRACK: "internal"
      ROLLOUT: ""

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare GH token
        run: echo "GH_TOKEN=${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV

      - name: Resolve release tag if 'latest'
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          if [ "$TAG" = "latest" ]; then
            REAL_TAG=$(gh release view --json tagName -q .tagName)
            echo "TAG=$REAL_TAG" >> $GITHUB_ENV
            echo "Using latest release tag: $REAL_TAG"
          else
            echo "TAG=$TAG" >> $GITHUB_ENV
          fi

      - name: Download AAB from GitHub Release
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          mkdir -p artifacts
          gh release download "$TAG" --pattern "$AAB_PATTERN" --dir artifacts
          AAB_FILE=$(ls artifacts/*.aab | head -n1 || true)
          if [ -z "$AAB_FILE" ]; then
            echo "❌ No .aab found matching pattern '$AAB_PATTERN' in release '$TAG'"; exit 1
          fi
          echo "AAB_PATH=$AAB_FILE" >> $GITHUB_ENV
          echo "Downloaded AAB: $AAB_FILE"

      - name: Read version info from repo files
        run: |
          if [ -f "$VERSION_NAME_FILE" ]; then
            VERSION_NAME=$(cat "$VERSION_NAME_FILE" | tr -d '\r\n')
          else
            echo "❌ Missing $VERSION_NAME_FILE"; exit 1
          fi
          if [ -f "$VERSION_CODE_FILE" ]; then
            VERSION_CODE=$(cat "$VERSION_CODE_FILE" | tr -d '\r\n')
          else
            echo "❌ Missing $VERSION_CODE_FILE"; exit 1
          fi
          echo "VERSION_NAME=$VERSION_NAME" >> $GITHUB_ENV
          echo "VERSION_CODE=$VERSION_CODE" >> $GITHUB_ENV
          echo "Using VersionName=$VERSION_NAME, VersionCode=$VERSION_CODE"

      - name: Set up Java (required by Play/fastlane pieces)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: false

      - name: Install Fastlane
        run: |
          echo 'source "https://rubygems.org"' > Gemfile
          echo 'gem "fastlane"' >> Gemfile
          bundle install --jobs 4 --retry 3

      # --- Upload to Google Play via your Fastlane lane (expects the "playstore" lane) ---
      - name: Upload to Google Play via Fastlane
        env:
          PLAY_JSON_KEY: ${{ secrets.PLAY_JSON_KEY }}
          SUPPLY_PACKAGE_NAME: ${{ secrets.SUPPLY_PACKAGE_NAME }}
        run: |
          bundle exec fastlane android playstore \
            version_name:"$VERSION_NAME" \
            version_code:"$VERSION_CODE" \
            aab:"$AAB_PATH" \
            track:"$TRACK" \
            rollout:"$ROLLOUT"

      # --- Download Google Play–signed APK (no local signing; uses Play's signature) ---
      - name: Download Google Play–signed APK via Fastlane
        env:
          PLAY_JSON_KEY: ${{ secrets.PLAY_JSON_KEY }}
          SUPPLY_PACKAGE_NAME: ${{ secrets.SUPPLY_PACKAGE_NAME }}
        run: |
          # This calls a lane that runs `supply` with `download_apks: true`
          # Add the lane `download_signed` to your Fastfile, as shown previously.
          bundle exec fastlane android download_signed

          # Find a downloaded APK (fastlane puts it under fastlane/metadata/android/.../apks)
          APK_PATH=$(find . -type f -name "*.apk" | head -n1 || true)
          if [ -z "$APK_PATH" ]; then
            echo "❌ No APK found after download"; find . -maxdepth 4 -type d -name "*apks*" -print; exit 1
          fi
          echo "APK_PATH=$APK_PATH" >> $GITHUB_ENV
          echo "Play-signed APK: $APK_PATH"

      # --- Replace only the AAB asset with the Play-signed APK (others untouched) ---
      - name: Delete existing AAB asset (keep others)
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          ASSETS=$(gh release view "$TAG" --json assets -q '.assets[].name')
          echo "Assets before: "; echo "$ASSETS"
          OLD_AAB=$(echo "$ASSETS" | grep -E '\.aab$' || true)
          if [ -n "$OLD_AAB" ]; then
            echo "Deleting AAB: $OLD_AAB"
            gh release delete-asset "$TAG" "$OLD_AAB" -y
          else
            echo "No .aab asset to delete."
          fi

      - name: Upload Play-signed APK (without touching other files)
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          # Optional: rename for clarity
          RENAMED="PlaySigned-${{ env.TAG }}.apk"
          cp "$APK_PATH" "$RENAMED"

          gh release upload "$TAG" "$RENAMED" --clobber
          echo "✅ Uploaded $RENAMED to release $TAG"

      - name: List final assets
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}
        run: |
          echo "Assets after:"
          gh release view "$TAG" --json assets -q '.assets[].name'
